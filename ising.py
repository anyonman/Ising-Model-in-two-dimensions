# -*- coding: utf-8 -*-
"""ising_new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hs6KIH3DiZclVLJHW9u4wVIrwDb7AOcH


Autor: Diego Rengifo, Universidad de los Andes. d.rengifo@uniandes.edu.co
Algortimo de simulacion del **Modelo de Ising** en dos dimensiones con condiciones de frontera periodicas.

El Hamiltoniano del modelo es
$\hat{H}=\sum_{ij}JS_i S_j $

donde la suma es sobre los pares $ij$ de primeros vecinos (para un espin fijo de la red, este interactua siempre con 4 elementos), $J$ es la constante de acople de los espines que asumiremos constante y por ultimo se asume condiciones de frontera periodica, es decir que la red es topologicamente equivalente a la superficie de un toro.

Se ha usado el metodo de Montecarlo para simular una red de espines de tamaño $L\times L$, a una temperatura $T$. Desde las relaciones simetricas de la red real y la red dual, se obtiene que la temperatura critica de la red esta dada como la solucion de la ecuacion $\sinh(\frac{2J}{k_B T})=1$.

Se tomará por conveniencia la constante de Boltmann como $k_B=1$.
Se usará $J=1$, por lo tanto esperamos una transicion de fase alrededor de $T_c=2.26919$.
"""

import numpy as np
from random import *
from pylab import *
import matplotlib.pyplot as plt
#import time

#time_start = time.time()
#time_elapsed = (time.time() - time_start)




#Primero construiremos funciones que nos permitan hallar el valor de la energia de la red, 
#al expandir los terminos del hamiltoniano, es relativamente facil darse cuenta que hay interacciones verticales y horizontales


#La funcion h_int(A) suma todas las interacciones horizontales incluida los terminos de frontera.
def h_int(A):
      BT=np.sum(A[:,0]*A[:,-1])
      suma=np.sum(A[:,1:]*A[:,:-1])
      return suma+BT


#La funcion h_int(A) suma todas las interacciones horizontales incluida los terminos de frontera.
def v_int(A):
  BT=np.sum(A[0,:]*A[-1,:])
  suma=np.sum(A[:-1,:]*A[1:,:])
  return suma+BT


#Finalmente, sumando las contribuciones de las interacciones horizontales y verticales y agregando el acople J se obtiene la energia
#de una configuracion dada.
# Se toma la constante J=1 solo por conveniencia.
def energy(A):
  J=1
  return -J*(h_int(A)+v_int(A))



#esta funcion genera una red aleatoria de tamaño LxL formada con 1 o -1
def ran_confi(L):
  A=np.random.randint(2,size=(L,L))
  return 2*A-np.ones(L)

#def flip(A,i,j):
#  if A[i,j]==1:
#    A[i,j]=-1
#  else:
#    A
#  return A  
#A=np.array([[-1,1]
#            ,[-1,1]])

#print(flip(A,1,0))

#Mplot=[]
#Eplot=[]

# La funcion Ising is la implementacion del algoritmo de montecarlo para la red previamente generada.
def Ising(T,L,N,A):
  Mplot=[]                    #lista vacia donde se agregaran los valores de la magnetizacion
  Eplot=[]                    #lista vacia donde se agregaran los valores de la energia
  E_0=energy(A)               #energia inicial
  M=np.sum(A)                 #magnetizacion inicial
  for k in range(N):          #loop para empezar los pasos de montecarlo
    i=randrange(L)            #eleccion aleatoria un espin de la red
    j=randrange(L)            
    A[i,j]=-1*A[i,j]          #Se hace el flip del espin seleccionado
    E_new=energy(A)           #se calcula la nueva energia despues del flip del espin
    M_new=np.sum(A)           #se calcula la nueva magnetizacion
    dE=E_new-E_0              #se calcula la diferencia respecto al valor inicial
    if dE<=0:       
      E_0=E_new               #se acepta el el flip y se calculan los nuevos valores de energia y magnetizacion
      M=M_new
    else:
      if random()<np.exp(-dE/T): # si dE<0, se entra a este condicional para saber si se acepta o no el flip
        E_0=E_new                # se acepto el flip. 
        M=M_new
      else:
        A[i,j]=-1*A[i,j]        # como no se acepta el flip, se debe regresar a su valor inicial, y regresando la energia y magnetizacion a su 
        E_0=energy(A)           # y regresando la energia y magnetizacion a su valor antes del flip.
        M=np.sum(A)
    Eplot.append(E_0)           #al llegar a este punto el flip ha sido aceptado o rechazado, se agregan los valores de enegia y magnetizacion
    Mplot.append(M)             # a las listas vacias del inicio.
  E_ave=np.mean(Eplot[int(0.7*N):])/L**2 #se usa para calcular los valores promedios despues del que el sistema se ha esatbilizado, se ha usan el 30% de los 
  M_ave=np.mean(Mplot[int(0.7*N):])/L**2  # datos finales, ademas de la normalizacion por el numero de espines de la red.
  return Eplot,Mplot,E_ave,M_ave    #valores que retorna la funcion Ising



"""Ya hemos escrito la parte fundamental del Algoritmo.  Veremos como se estabiliza el valor de la energia apartir de cierto numero de interaciones."""

# Tomaremos la temperatura como T=1, una red de 20x20 y un valor de 100000 iteraciones.

T=1
L=20
N=1000000
A=ran_confi(L)  #Se genera la red aleatoria de tamaño LxL

plt.plot(Ising(T,L,N,A)[0])  # se toma el valor de output Eplot de Ising
plt.xlabel('Iteraciones')
plt.title('Estabilizacion de la Energia')
plt.ylabel('Energia Total de la Red')
plt.show()

plt.plot(Ising(T,L,N,A)[1])  # se toma el valor de output Eplot de Ising
plt.xlabel('Iteraciones')
plt.ylim(ymin=-500, ymax=500 )
plt.title('Estabilizacion de la Magnetizacion')
plt.ylabel('Magnetizacion Total de la Red')
plt.show()




"""Ahora veremos como es la grafica de la magnetizacion vs temperatura, recordar que la temperatura critica para nuestra eleccion de parametros es alrededor de $T_c=2.27$. Debio a la cantidad de procesos esto tomará bastante tiempo, alrededor de 20min usando esta plataforma Colab."""

L=20
N=1000000
B=ran_confi(L)



#range_1=np.linspace(2.1,2.4,5)  # Esto genera valores alrededor de T_c, desde 2.1 a 2.4
#range_2=np.linspace(0.5,5,20)     #Esto genera mas valores en un rango mas amplio
#Temp=np.concatenate((range_1,range_2))  # esto genera un arreglo no uniforme de valores de T, con mas valores cerca a T_c para observar mejor la transicion.
Temp=np.linspace(1,5,20)
Mag=[]
E=[]
for T in Temp:            #repetimos las funcion ising para los varios valores de temperatura 
  M_ave=Ising(T,L,N,B)[3]  #extraemos los valores de la magnetizacion promedio dados por Ising
  E_ave=Ising(T,L,N,B)[2]
  Mag.append(abs(M_ave))
  E.append(E_ave)
plt.grid('on')
plt.xlabel('Temperatura')
plt.ylabel('Magnetizacion por Espin')
plt.title('Magnetizacion vs Temperatura')
plt.scatter(Temp,Mag)
plt.show()
plt.clf()
plt.grid('on')
plt.xlabel('Temperatura')
plt.ylabel('Energia promedio por espin')
plt.title('Energia promedio por espin vs Temperatura')
plt.scatter(Temp,E)
plt.show()

"""Hasta este momento, cada uno de los puntos de las graficas fue calculado con una sola corrida del algoritmo metropolis y a apesar de esto, los resulatdos obtenidos concuerdan con los reportados en la literatura, salvo algunas fluctuaciones, en especial cerca a $T_c$. Debido al caracter estocastico del algoritmo, para cada una de las temperaturas se correra el algoritmo Ising $n$ veces, estos valores se promedian y esto me dará una temperatura promediada, este proceso se repite para cada temperatura y se hara de nuevo la grafica de la magnetizacion vs temperatura donde se incluyen barras de error que especifica la dispersion en la toma de datos de la temperatura.

Debido a la cantidad de procesos involucrados, este algortimo tarda mucho mas tiempo que el anterior.
"""

def array_mean_Mag(n,Temp,L): #para cada T fija, se correra Ising n-veces
  mag=[]
  disper=[]
  for T in Temp:
    mag_T_fija=[]
    for i in range(n):
      A=ran_confi(L)
      mag_T_fija.append(abs(Ising(T,L,N,A)[3]))
    x=np.mean(mag_T_fija)
    #sigma=np.var(mag_T_fija)
    mag.append(x)
    #disper.append(sigma)
  return np.array(mag)#,np.array(disper)

N=800000
L=20
#range_1=np.linspace(2.1,2.4,5) 
#range_2=np.linspace(0.5,5,10)
#Temp=np.concatenate((range_1,range_2))
Temp=np.linspace(1,4,15)
n=5
mag=array_mean_Mag(n,Temp,L)
plt.scatter(Temp,mag)
#e=array_mean_Mag(n,Temp,L)[1]/2.0
#plt.errorbar(Temp, mag, yerr=e, fmt='o')
plt.grid('on')
plt.xlabel('Temperatura')
plt.ylabel('Magnetizacion por Espin')
plt.title('Magnetizacion vs Temperatura')
plt.show()
#print (time_elapsed)
